Project 0
09/01/2016
Yadu Bhageria
00733164

I.a.

For /n:
Hello
World!
\n places a new line between the words

For \t:
Hello	World!
\t places a tab between the words

For \v:
Hello
     World!
\v places a “vertical tab” between the words. That is a new line and “World” starts on the column after the column where “Hello” ends

For \b:
HellWorld!
\b outputs a backspace after “Hello” which causes the “o” to be deleted

For \r:
World!
\r places a carriage return between the characters. That is deleting everything and starting from the beginning of the line

For \f:
Hello
     World!
\f places a “formfeed” between the words. That is it causes a page to be printed which in this case just moves the output to the next line (similar to \v)

For \a:
HelloWorld!
\a causes the system to beep

For \\:
Hello\World!
\\ outputs the character \

For \?:
Hello?World!
\? outputs the character ?

For \’:
Hello’World!
\’ outputs the character ‘

For \”:
Hello”World!
\” outputs the character “

Note: There are no changes by using a different compiler as C is standardised with ISO C characters.

I.b.

#include <stdio.h>

int main(void) {
printf("         Name: <Bhageria, Yadu>\n          CID: <00733164>\n   LIBRARY NO: <0246618471>\nEmail Address: <yrb13@ic.ac.uk>\n  Course Code: <M3SC>");
return(0);
}

         Name: <Bhageria, Yadu>
          CID: <00733164>
   LIBRARY NO: <0246618471>
Email Address: <yrb13@ic.ac.uk>
  Course Code: <M3SC>

II.

#include <stdio.h>
int main(void) 
{
	int i1=4, i2=11111, i3=777777777;
	float x1=2.0,x2=2.4048255576957728,x3=6.02214e23;
	printf("i1, i2, i3 = %d %d %d \n",i1,i2,i3);
	printf("x1, x2, x3 = %f %f %f \n",x1,x2,x3);
	return(0);
}

Output:
i1, i2, i3 = 4 11111 777777777 
x1, x2, x3 = 2.000000 2.404825 602213992297390856470528.000000 

a. with %8d instead of %d:
i1, i2, i3 =        4    11111 777777777 
x1, x2, x3 = 2.000000 2.404825 602213992297390856470528.000000
%8d uses at least 8 spaces for the output. If the digit is smaller then it fills the unused space with spaces before the number and if its longer then it outputs the entire number.

b. with %4d instead of %d:
i1, i2, i3 =    4 11111 777777777 
x1, x2, x3 = 2.000000 2.404825 602213992297390856470528.000000 
same as with %8d but with 4 spaces instead of 8.

c. with %e instead of %f:
i1, i2, i3 = 4 11111 777777777 
x1, x2, x3 = 2.000000e+00 2.404825e+00 6.022140e+23 
%e makes the numbers output as standard form

d. with %E instead of %f:
i1, i2, i3 = 4 11111 777777777 
x1, x2, x3 = 2.000000E+00 2.404825E+00 6.022140E+23 
again outputs in standard form and makes the “e” in the standard form capitalised to “E”

e. with %g instead of %f:
i1, i2, i3 = 4 11111 777777777 
x1, x2, x3 = 2 2.40483 6.02214e+23 
%g specifics the significant figures to be outputted. If this is not specified then 6 is used a default value. If the number is greater than 6 digits then standard form is used. Trailing zeros are removed from the fractional part of the result and decimals only appear if there is at least 1 non zero value part the decimal

f. with %10.2g instead of %f:
i1, i2, i3 = 4 11111 777777777 
x1, x2, x3 =          2        2.40482544899      6e+23 
in %10.2g(/%20.12g) the 10(/20) specifies the amount of space to be used for each output (as with %8d) and the .2(/.12) specifies the number of significant figures to be used. 

with double instead of float:
i1, i2, i3 = 4 11111 777777777 
x1, x2, x3 = 2.000000 2.404826 602213999999999969067008.000000 
Double allocated double the number of bits to store the value. The output becomes more accurate.

III.

#include <stdio.h>
int main(void) 
{
	short i1=44,i2=55,i3;
	i3=i1+i2;
	printf("i1, i2, i3 = %d %d %d \n", i1,i2,i3);
	return(0);
}

i1, i2, i3 = 44 55 99

a. 
i1, i2, i3 = 44 55 0 
Yes, this is expected. i1 and i2 multiply.

b. 
i1, i2, i3 = 44 55 0 
Yes, this is expected. i1/i2 is smaller than 1 which rounds down to its integer value of 0.

c.
i1, i2, i3 = 44 55 1 
Yes, this is expected. i2/i1 is greater than 1 and smaller than 2 so it rounds down to the integer component of 1

d. 
i1, i2, i3 = -21092 -9981 -31073
Yes, this is expected. 2^16 is 65536 and 44444-2^16=-21092, 55555-2^16=-9981 and i1+i2=99999 and -31073=99999-2^16. Short means our outputs are in a ring of value 2^16. 

For new values i1=44444, i2=55555:
e.
i1, i2, i3 = -21092 -9981 17620 
44444-2^16=-21092, 55555-2^16=-9981 and 44444*55555-(37675*2^16) = 17620

f.
i1, i2, i3 = -21092 -9981 2 
44444-2^16=-21092, 55555-2^16=-9981 and -9981 goes into -21091 twice so outputs 2

g.
i1, i2, i3 = -21092 -9981 0 
44444-2^16=-21092, 55555-2^16=-9981 and -21092 goes into -9981 zero times so outputs 0

IV.

2^-24 = 5.96 x 10^-8
2^-52 = 1.11 x 10^-16
2^-113 = 9.63 x 10^-35

#include <stdio.h>
int main(void) 
{
	float x1=1.0e6,x2=2.4048255576957728,x3;
	x3=x1+x2;
	printf("x1, x2, x3 = %f %f %f \n", x1,x2,x3);
	return(0);
}

x1, x2, x3 = 1000000.000000 2.404825 1000002.375000 
Yes, this is expected. x3 is calculated to an accuracy of 7-8 significant figures as 24 bits are used for storing the significand. We can note this by seeing the sum, 1000002.4048255, rounded down to 7-8 significant figures is equal to the value here.

a.
x1, x2, x3 = 1000000.000000 2.404825 2404825.500000 
Yes, this is expected. x3 is calculated to 7-8 significant figures precision. 2.4048255576957728 truncated to 7-8 significant figures and multiplied by 1^6 which is the value outputted with the default of 6 decimal places for %f

b.
x1, x2, x3 = 1000000.000000 2.404825 415830.593750 
Yes, this is expected. Again 2.4048255576957728 truncated to 7-8 significant figures and then 1000000.0 / 2.4048255 = 415830.587292 which is again truncated to 415830.593750 

c.
x1, x2, x3 = 1000000.000000 2.404825 0.000002
Yes, this is expected. Similar as above but when we divide  2.4048255 / 1000000.0 = 0.00000240482 which is truncated down to 0.000002 due to the default of 6 decimal places for %f

d.
Doesn’t compile. modulo in gcc doesn’t work with floats. 

e. 
x1, x2, x3 = 602213992297390856470528.000000 299999995292024832.000000 602214280527767008182272.000000
x1 and x2 are accurate to between 7-8 significant figures. x3 works by adding 602213992297390856470528.000000 to 299999995292024832.000000 which gives 602214280527767008182272.000000 to 7-8 significant figures. 

f.
x1, x2, x3 = 602213992297390856470528.000000 299999995292024832.000000 inf 
Yes, this is expected 
